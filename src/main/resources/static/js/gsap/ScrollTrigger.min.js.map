{"version":3,"file":"ScrollTrigger.min.js","sources":["../src/ScrollTrigger.js"],"sourcesContent":["/*!\n * ScrollTrigger 3.3.4\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _raf, _request, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i,\n\t_limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n\t_startup = 1,\n\t_getTime = Date.now,\n\t_time1 = _getTime(),\n\t_lastScrollTime = 0,\n\t_enabled = 1,\n\t_passThrough = v => v,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_isViewport = e => !!~_root.indexOf(e),\n\t_getScrollFunc = (element, {s}) => function(value) { return arguments.length ? (element[s] = value) : element[s]; },\n\t_maxScroll = (element, {s, d2}) => (s = \"scroll\" + d2) && _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win[\"inner\" + d2] || _docEl[\"client\" + d2] || _body[\"client\" + d2]) : element[s] - element[\"offset\" + d2],\n\t_isString = value => typeof(value) === \"string\",\n\t_isFunction = value => typeof(value) === \"function\",\n\t_isNumber = value => typeof(value) === \"number\",\n\t_isObject = value => typeof(value) === \"object\",\n\t_abs = Math.abs,\n\t_scrollLeft = \"scrollLeft\",\n\t_scrollTop = \"scrollTop\",\n\t_left = \"left\",\n\t_top = \"top\",\n\t_right = \"right\",\n\t_bottom = \"bottom\",\n\t_width = \"width\",\n\t_height = \"height\",\n\t_Right = \"Right\",\n\t_Left = \"Left\",\n\t_Top = \"Top\",\n\t_Bottom = \"Bottom\",\n\t_padding = \"padding\",\n\t_margin = \"margin\",\n\t_Width = \"Width\",\n\t_Height = \"Height\",\n\t_px = \"px\",\n\t_horizontal = {s: _scrollLeft, p: _left, p2: _Left, os: _right, os2: _Right, d: _width, d2: _Width, a: \"x\", sc: function(value) { return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0}},\n\t_vertical = {s: _scrollTop, p: _top, p2: _Top, os: _bottom, os2: _Bottom, d: _height, d2: _Height, a: \"y\", op: _horizontal, sc: function(value) { return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0}},\n\t_getComputedStyle = element => _win.getComputedStyle(element),\n\t_makePositionable = element => element.style.position = (_getComputedStyle(element).position === \"absolute\") ? \"absolute\" : \"relative\", // if the element already has position: absolute, leave that, otherwise make it position: relative\n\t_setDefaults = (obj, defaults) => {\n\t\tfor (let p in defaults) {\n\t\t\t(p in obj) || (obj[p] = defaults[p]);\n\t\t}\n\t\treturn obj;\n\t},\n\t//_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,\n\t_getBounds = (element, withoutTransforms) => {\n\t\tlet tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0}).progress(1),\n\t\t\tbounds = element.getBoundingClientRect();\n\t\ttween && tween.progress(0).kill();\n\t\treturn bounds;\n\t},\n\t_getSize = (element, {d2}) => element[\"offset\" + d2] || element[\"client\" + d2] || 0,\n\t_getLabels = animation => {\n\t\treturn value => {\n\t\t\tlet a = [],\n\t\t\t\tlabels = animation.labels,\n\t\t\t\tduration = animation.duration(),\n\t\t\t\tp;\n\t\t\tfor (p in labels) {\n\t\t\t\ta.push(labels[p] / duration);\n\t\t\t}\n\t\t\treturn gsap.utils.snap(a, value);\n\t\t};\n\t},\n\t_multiListener = (func, element, types, callback) => types.split(\",\").forEach(type => func(element, type, callback)),\n\t_addListener = (element, type, func) => element.addEventListener(type, func, {passive: true}),\n\t_removeListener = (element, type, func) => element.removeEventListener(type, func),\n\t_markerDefaults = {startColor: \"green\", endColor: \"red\", indent: 0, fontSize: \"16px\", fontWeight:\"normal\"},\n\t_defaults = {toggleActions: \"play\", anticipatePin: 0},\n\t_keywords = {top: 0, left: 0, center: 0.5, bottom: 1, right: 1},\n\t_offsetToPx = (value, size) => {\n\t\tif (_isString(value)) {\n\t\t\tlet eqIndex = value.indexOf(\"=\"),\n\t\t\t\trelative = ~eqIndex ? +(value.charAt(eqIndex-1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\t\t\tif (relative) {\n\t\t\t\t(value.indexOf(\"%\") > eqIndex) && (relative *= size / 100);\n\t\t\t\tvalue = value.substr(0, eqIndex-1);\n\t\t\t}\n\t\t\tvalue = relative + ((value in _keywords) ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n\t\t}\n\t\treturn value;\n\t},\n\t_createMarker = (type, name, container, direction, {startColor, endColor, fontSize, indent, fontWeight}, offset, matchWidthEl) => {\n\t\tlet e = _doc.createElement(\"div\"),\n\t\t\tisViewport = _isViewport(container),\n\t\t\tisScroller = type.indexOf(\"scroller\") !== -1,\n\t\t\tparent = isViewport ? _body : container,\n\t\t\tisStart = type.indexOf(\"start\") !== -1,\n\t\t\tcolor = isStart ? startColor : endColor,\n\t\t\tcss = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\t\tcss += \"position:\" + (isScroller && isViewport ? \"fixed;\" : \"absolute;\");\n\t\t(isScroller || !isViewport) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n\t\tmatchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n\t\te._isStart = isStart;\n\t\te.setAttribute(\"class\", \"gsap-marker-\" + type);\n\t\te.style.cssText = css;\n\t\te.innerText = name || name === 0 ? type + \"-\" + name : type;\n\t\tparent.insertBefore(e, parent.children[0]);\n\t\te._offset = e[\"offset\" + direction.op.d2];\n\t\t_positionMarker(e, 0, direction, isViewport, isStart);\n\t\treturn e;\n\t},\n\t_positionMarker = (marker, start, direction, isViewport, flipped) => {\n\t\tlet vars = {},\n\t\t\tside = direction[flipped ? \"os2\" : \"p2\"],\n\t\t\toppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n\t\tmarker._isFlipped = flipped;\n\t\tvars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n\t\tvars[direction.a] = flipped ? 1 : 0;\n\t\tvars[\"border\" + side + _Width] = 1;\n\t\tvars[\"border\" + oppositeSide + _Width] = 0;\n\t\tvars[direction.p] = start;\n\t\tgsap.set(marker, vars);\n\t},\n\t_triggers = [],\n\t_ids = {},\n\t_sync = () => _request || (_request = _raf(_updateAll)),\n\t_onScroll = () => {\n\t\tif (!_request) {\n\t\t\t_request = _raf(_updateAll);\n\t\t\t_lastScrollTime || _dispatch(\"scrollStart\");\n\t\t\t_lastScrollTime = _getTime();\n\t\t}\n\t},\n\t_onResize = () => !_refreshing && (_getTime() - _lastScrollTime > 200) && _resizeDelay.restart(true), // ignore resizes that occur DURING a scroll as well as those triggered by refresh()\n\t_listeners = {},\n\t_emptyArray = [],\n\t_dispatch = type => (_listeners[type] && _listeners[type].map(f => f())) || _emptyArray,\n\t_refreshAll = force => {\n\t\tlet refreshInits = _dispatch(\"refreshInit\"),\n\t\t\tl = _triggers.length;\n\t\t_i = l;\n\t\twhile (_i--) {\n\t\t\t_triggers[_i].scroll.rec = _triggers[_i].scroll(); // record the scroll positions so that in each refresh() we can ensure that it doesn't shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times.\n\t\t}\n\t\tfor (_i = 0; _i < l; _i++) {\n\t\t\t_triggers[_i] && _triggers[_i].refresh(force !== true);\n\t\t}\n\t\trefreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\t\t_i = _triggers.length;\n\t\twhile (_i--) {\n\t\t\t_triggers[_i].scroll.rec = 0;\n\t\t}\n\t\t_dispatch(\"refresh\");\n\t},\n\t_updateAll = () => {\n\t\tlet l = _triggers.length,\n\t\t\ttime = _getTime(),\n\t\t\trecordVelocity = time - _time1 >= 50;\n\t\tif (recordVelocity) {\n\t\t\tif (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n\t\t\t\t_lastScrollTime = 0;\n\t\t\t\t_dispatch(\"scrollEnd\");\n\t\t\t}\n\t\t\t_time2 = _time1;\n\t\t\t_time1 = time;\n\t\t}\n\t\tfor (_i = 0; _i < l; _i++) {\n\t\t\t_triggers[_i] && _triggers[_i].update(0, recordVelocity);\n\t\t}\n\t\t_request = 0;\n\t},\n\t_propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\"],\n\t_stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n\t_swapPinOut = (pin, spacer, state) => {\n\t\t_setState(state);\n\t\tif (pin.parentNode === spacer) {\n\t\t\tlet parent = spacer.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.insertBefore(pin, spacer);\n\t\t\t\tparent.removeChild(spacer);\n\t\t\t}\n\t\t}\n\t},\n\t_swapPinIn = (pin, spacer, cs) => {\n\t\tif (pin.parentNode !== spacer) {\n\t\t\tlet i = _propNamesToCopy.length,\n\t\t\t\tspacerStyle = spacer.style,\n\t\t\t\tpinStyle = pin.style,\n\t\t\t\tp;\n\t\t\twhile (i--) {\n\t\t\t\tp = _propNamesToCopy[i];\n\t\t\t\tspacerStyle[p] = cs[p];\n\t\t\t}\n\t\t\tspacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n\t\t\tpinStyle[_bottom] = pinStyle[_right] = \"auto\";\n\t\t\tspacerStyle.overflow = \"visible\";\n\t\t\tspacerStyle.boxSizing = \"border-box\";\n\t\t\tspacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n\t\t\tspacerStyle[_height] = _getSize(pin, _vertical) + _px;\n\t\t\tspacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\t\t\tpinStyle[_width] = cs[_width];\n\t\t\tpinStyle[_height] = cs[_height];\n\t\t\tpinStyle[_padding] = cs[_padding];\n\t\t\tpin.parentNode.insertBefore(spacer, pin);\n\t\t\tspacer.appendChild(pin);\n\t\t}\n\t},\n\t_capsExp = /([A-Z])/g,\n\t_setState = state => {\n\t\tlet style = state.t.style,\n\t\t\tl = state.length,\n\t\t\ti = 0,\n\t\t\tp, value;\n\t\tfor (; i < l; i +=2) {\n\t\t\tvalue = state[i+1];\n\t\t\tp = state[i];\n\t\t\tif (value) {\n\t\t\t\tstyle[p] = value;\n\t\t\t} else if (style[p]) {\n\t\t\t\tstyle.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n\t\t\t}\n\t\t}\n\t},\n\t_getState = element => { // returns an array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n\t\tlet l = _stateProps.length,\n\t\t\tstyle = element.style,\n\t\t\tstate = [],\n\t\t\ti = 0;\n\t\tfor (; i < l; i++) {\n\t\t\tstate.push(_stateProps[i], style[_stateProps[i]]);\n\t\t}\n\t\tstate.t = element;\n\t\treturn state;\n\t},\n\t_copyState = (state, override, omitOffsets) => {\n\t\tlet result = [],\n\t\t\tl = state.length,\n\t\t\ti = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n\t\t\tp;\n\t\tfor (; i < l; i += 2) {\n\t\t\tp = state[i];\n\t\t\tresult.push(p, (p in override) ? override[p] : state[i+1]);\n\t\t}\n\t\tresult.t = state.t;\n\t\treturn result;\n\t},\n\t_winOffsets = {left:0, top:0},\n\t_parsePosition = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, isViewport, scrollerMax) => {\n\t\t_isFunction(value) && (value = value(self));\n\t\tif (_isString(value) && value.substr(0,3) === \"max\") {\n\t\t\tvalue = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n\t\t}\n\t\tif (!_isNumber(value)) {\n\t\t\t_isFunction(trigger) && (trigger = trigger(self));\n\t\t\tlet element = _toArray(trigger)[0] || _body,\n\t\t\t\tbounds = _getBounds(element) || {},\n\t\t\t\toffsets = value.split(\" \"),\n\t\t\t\tlocalOffset, globalOffset, display;\n\t\t\tif ((!bounds || (!bounds.left && !bounds.top)) && _getComputedStyle(element).display === \"none\") { // if display is \"none\", it won't report getBoundingClientRect() properly\n\t\t\t\tdisplay = element.style.display;\n\t\t\t\telement.style.display = \"block\";\n\t\t\t\tbounds = _getBounds(element);\n\t\t\t\tdisplay ? (element.style.display = display) : element.style.removeProperty(\"display\");\n\t\t\t}\n\t\t\tlocalOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n\t\t\tglobalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n\t\t\tvalue = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n\t\t\tmarkerScroller && _positionMarker(markerScroller, globalOffset, direction, isViewport, (scrollerSize - globalOffset < 20 || (markerScroller._isStart && globalOffset > 20)));\n\t\t\tscrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n\t\t} else if (markerScroller) {\n\t\t\t_positionMarker(markerScroller, scrollerSize, direction, isViewport, true);\n\t\t}\n\t\tif (marker) {\n\t\t\tlet position = value + scrollerSize,\n\t\t\t\tisStart = marker._isStart;\n\t\t\tscrollerMax = \"scroll\" + direction.d2;\n\t\t\t_positionMarker(marker, position, direction, isViewport, (isStart && position > 20) || (!isStart && (isViewport ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1)); // marker.style[direction.p] = (value + scrollerSize - (isViewport ? direction.m : 0)) + \"px\";\n\t\t\tif (isViewport) {\n\t\t\t\tscrollerBounds = _getBounds(markerScroller);\n\t\t\t\tisViewport && (marker.style[direction.op.p] = (scrollerBounds[direction.op.p] - direction.op.m - marker._offset) + _px);\n\t\t\t}\n\t\t}\n\t\treturn Math.round(value);\n\t},\n\t_prefixExp = /(?:webkit|moz|length)/i,\n\t_reparent = (element, parent) => {\n\t\tif (element.parentNode !== parent) {\n\t\t\tlet style = element.style,\n\t\t\t\tp, cs;\n\t\t\tif (parent === _body) {\n\t\t\t\telement._stOrig = style.cssText; // record original inline styles so we can revert them later\n\t\t\t\tcs = _getComputedStyle(element);\n\t\t\t\tfor (p in cs) { // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n\t\t\t\t\tif (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n\t\t\t\t\t\tstyle[p] = cs[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstyle.cssText = element._stOrig;\n\t\t\t}\n\t\t\tparent.appendChild(element);\n\t\t}\n\t},\n\t// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n\t_getTweenCreator = (scroller, direction) => {\n\t\tlet getScroll = _isViewport(scroller) ? direction.sc : _getScrollFunc(scroller, direction),\n\t\t\tprop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n\t\t\tlastScroll,\n\t\t\tgetTween = (scrollTo, vars, initialValue, change1, change2) => {\n\t\t\t\tlet tween = getTween.tween,\n\t\t\t\t\tonComplete = vars.onComplete,\n\t\t\t\t\tmodifiers = {};\n\t\t\t\ttween && tween.kill();\n\t\t\t\tlastScroll = getScroll();\n\t\t\t\tvars[prop] = scrollTo;\n\t\t\t\tvars.modifiers = modifiers;\n\t\t\t\tmodifiers[prop] = value => {\n\t\t\t\t\tif (getScroll() !== lastScroll) { // if the user scrolls, kill the tween!\n\t\t\t\t\t\ttween.kill();\n\t\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\t\tvalue = getScroll();\n\t\t\t\t\t} else if (change1) {\n\t\t\t\t\t\tvalue = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n\t\t\t\t\t}\n\t\t\t\t\treturn (lastScroll = Math.round(value));\n\t\t\t\t};\n\t\t\t\tvars.onComplete = () => {\n\t\t\t\t\tgetTween.tween = 0;\n\t\t\t\t\tonComplete && onComplete.call(tween);\n\t\t\t\t};\n\t\t\t\ttween = getTween.tween = gsap.to(scroller, vars);\n\t\t\t\treturn tween;\n\t\t\t};\n\t\tscroller[prop] = getScroll;\n\t\treturn getTween;\n\t};\n\n_horizontal.op = _vertical;\n\n\n\nexport class ScrollTrigger {\n\n\tconstructor(vars, animation) {\n\t\t_coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n\t\tthis.init(vars, animation);\n\t}\n\n\tinit(vars, animation) {\n\t\tthis.progress = 0;\n\t\tthis.vars && this.kill(1); // in case it's being initted again\n\t\tif (!_enabled) {\n\t\t\tthis.update = this.refresh = this.kill = _passThrough;\n\t\t\treturn;\n\t\t}\n\t\tvars = _setDefaults((_isString(vars) || _isNumber(vars) || vars.nodeType) ? {trigger: vars} : vars, _defaults);\n\t\tlet direction = vars.horizontal ? _horizontal : _vertical,\n\t\t\t{onUpdate, toggleClass, id, onToggle, onRefresh, scrub, trigger, pin, pinSpacing, invalidateOnRefresh, anticipatePin, onScrubComplete, onSnapComplete, once, snap, pinReparent} = vars,\n\t\t\tisToggle = !scrub && scrub !== 0,\n\t\t\tscroller = _toArray(vars.scroller || _win)[0],\n\t\t\tscrollerCache = gsap.core.getCache(scroller),\n\t\t\tisViewport = _isViewport(scroller),\n\t\t\tcallbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n\t\t\ttoggleActions = isToggle && (once ? \"play\" : vars.toggleActions).split(\" \"),\n\t\t\tmarkers = \"markers\" in vars ? vars.markers : _defaults.markers,\n\t\t\tborderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n\t\t\tself = this,\n\t\t\tsoftRefresh = () => ScrollTrigger.removeEventListener(\"scrollEnd\", softRefresh) || self.refresh(),\n\t\t\tonRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),\n\t\t\ttweenTo, pinCache, snapFunc, isReverted, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars,\n\t\t\tchange, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacingActive, markerStartSetter,\n\t\t\tmarkerEndSetter, cs, snap1, snap2, scrubScrollTime, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, enabled;\n\n\t\tanticipatePin *= 45;\n\t\t_triggers.push(self);\n\t\tself.scroller = scroller;\n\t\tself.scroll = isViewport ? direction.sc : _getScrollFunc(scroller, direction);\n\t\tscroll1 = self.scroll();\n\t\tself.vars = vars;\n\t\tanimation = animation || vars.animation;\n\t\tscrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n\t\t\ttop: _getTweenCreator(scroller, _vertical),\n\t\t\tleft: _getTweenCreator(scroller, _horizontal)\n\t\t};\n\t\tself.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\t\tif (animation) {\n\t\t\tanimation.vars.lazy = false;\n\t\t\tanimation._initted || (animation.vars.immediateRender !== false && animation.render(-0.01, true, true));\n\t\t\tself.animation = animation.pause();\n\t\t\tanimation.scrollTrigger = self;\n\t\t\tscrubSmooth = _isNumber(scrub) && scrub;\n\t\t\tscrubSmooth && (scrubTween = gsap.to(animation, {ease: \"power3\", duration: scrubSmooth, onComplete: () => onScrubComplete && onScrubComplete(self)}));\n\t\t\tsnap1 = 0;\n\t\t\tid || (id = animation.vars.id);\n\t\t}\n\t\tif (snap) {\n\t\t\t_isObject(snap) || (snap = {snapTo: snap});\n\t\t\tsnapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getLabels(animation) : gsap.utils.snap(snap.snapTo);\n\t\t\tsnapDurClamp = snap.duration || {min: 0.1, max: 2};\n\t\t\tsnapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n\t\t\tsnapDelayedCall = gsap.delayedCall(snap.delay || (scrubSmooth / 2) || 0.1, () => {\n\t\t\t\tif (!_lastScrollTime || (_lastScrollTime === scrubScrollTime && !_pointerIsDown)) {\n\t\t\t\t\tlet totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n\t\t\t\t\t\tvelocity = ((totalProgress - snap2) / (_getTime() - _time2) * 1000) || 0,\n\t\t\t\t\t\tchange1 = _abs(velocity / 2) * velocity / 0.185,\n\t\t\t\t\t\tnaturalEnd = totalProgress + change1,\n\t\t\t\t\t\tendValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n\t\t\t\t\t\tchange2 = endValue - totalProgress - change1,\n\t\t\t\t\t\tscroll = self.scroll(),\n\t\t\t\t\t\tendScroll = Math.round(start + endValue * change),\n\t\t\t\t\t\ttween = tweenTo.tween;\n\t\t\t\t\tif (scroll <= end && scroll >= start) {\n\t\t\t\t\t\tif (tween && !tween._initted) { // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n\t\t\t\t\t\t\tif (tween.data <= Math.abs(endScroll - scroll)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttween.kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttweenTo(endScroll, {\n\t\t\t\t\t\t\tduration: snapDurClamp(_abs( (Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05) || 0)),\n\t\t\t\t\t\t\tease: snap.ease || \"power3\",\n\t\t\t\t\t\t\tdata: Math.abs(endScroll - scroll), // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n\t\t\t\t\t\t\tonComplete: () => {\n\t\t\t\t\t\t\t\tsnap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n\t\t\t\t\t\t\t\tonSnapComplete && onSnapComplete(self);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, start + totalProgress * change, change1 * change, change2 * change);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsnapDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t}).pause();\n\t\t}\n\t\tid && (_ids[id] = self);\n\t\ttrigger = self.trigger = _toArray(trigger || pin)[0];\n\t\tpin = pin === true ? trigger : _toArray(pin)[0];\n\t\t_isString(toggleClass) && (toggleClass = {targets: trigger, className: toggleClass});\n\t\tif (pin) {\n\t\t\t(pinSpacing === false || pinSpacing === _margin) || (pinSpacing = _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\t\t\tself.pin = pin;\n\t\t\tvars.force3D !== false && gsap.set(pin, {force3D: true});\n\t\t\tpinCache = gsap.core.getCache(pin);\n\t\t\tif (!pinCache.spacer) { // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n\t\t\t\tpinCache.spacer = spacer = _doc.createElement(\"div\");\n\t\t\t\tspacer.setAttribute(\"class\", \"pin-spacer\" + (id ? \" pin-spacer-\" + id : \"\"));\n\t\t\t\tpinCache.pinState = pinOriginalState = _getState(pin);\n\t\t\t} else {\n\t\t\t\tpinOriginalState = pinCache.pinState;\n\t\t\t}\n\t\t\tself.spacer = spacer = pinCache.spacer;\n\t\t\tcs = _getComputedStyle(pin);\n\t\t\tspacingStart = cs[pinSpacing + direction.os2];\n\t\t\tpinGetter = gsap.getProperty(pin);\n\t\t\tpinSetter = gsap.quickSetter(pin, direction.a, _px);\n\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\tpinState = _getState(pin);\n\t\t}\n\t\tif (markers) {\n\t\t\tmarkerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n\t\t\tmarkerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n\t\t\tmarkerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n\t\t\toffset = markerStartTrigger[\"offset\" + direction.op.d2];\n\t\t\tmarkerStart = _createMarker(\"start\", id, scroller, direction, markerVars, offset);\n\t\t\tmarkerEnd =_createMarker(\"end\", id, scroller, direction, markerVars, offset);\n\t\t\tif (!isViewport) {\n\t\t\t\t_makePositionable(scroller);\n\t\t\t\tgsap.set([markerStartTrigger, markerEndTrigger], {force3D: true});\n\t\t\t\tmarkerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n\t\t\t\tmarkerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n\t\t\t}\n\t\t}\n\n\t\tself.revert = revert => {\n\t\t\tlet r = revert !== false;\n\t\t\tif (r !== isReverted) {\n\t\t\t\tself.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\t\t\t\tpin && r && _swapPinOut(pin, spacer, pinOriginalState);\n\t\t\t\tisReverted = r;\n\t\t\t}\n\t\t}\n\n\n\t\tself.refresh = soft => {\n\t\t\tif (_refreshing || !enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pin && soft && _lastScrollTime) {\n\t\t\t\t_addListener(ScrollTrigger, \"scrollEnd\", softRefresh);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet prevScroll = Math.max(self.scroll(), self.scroll.rec || 0), // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\t\t\t\tprevProgress = self.progress,\n\t\t\t\tprevAnimProgress = animation && animation.progress();\n\t\t\t_refreshing = 1;\n\t\t\tscrubTween && scrubTween.kill();\n\t\t\tinvalidateOnRefresh && animation && animation.progress(0).invalidate().progress(self.progress);\n\t\t\tisReverted || self.revert();\n\t\t\tlet size = (isViewport ? _win[\"inner\" + direction.d2] : scroller[\"client\" + direction.d2]) || 0,\n\t\t\t\tscrollerBounds = isViewport ? _winOffsets : _getBounds(scroller),\n\t\t\t\tmax = _maxScroll(scroller, direction),\n\t\t\t\toffset = 0,\n\t\t\t\totherPinOffset = 0,\n\t\t\t\tparsedEnd = vars.end,\n\t\t\t\tparsedEndTrigger = vars.endTrigger || trigger,\n\t\t\t\tparsedStart = vars.start || (pin || !trigger ? \"0 0\" : \"0 100%\"),\n\t\t\t\tpinIndex = pin && Math.max(0, _triggers.indexOf(self)) || 0,\n\t\t\t\tcs, bounds, scroll, isVertical, override, i, curTrigger;\n\t\t\tif (pinIndex) { // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n\t\t\t\ti = pinIndex;\n\t\t\t\twhile (i--) {\n\t\t\t\t\t_triggers[i].pin === pin && _triggers[i].revert();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, isViewport, max) || (pin ? -0.001 : 0);\n\t\t\t_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\t\t\tif (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n\t\t\t\tif (~parsedEnd.indexOf(\" \")) {\n\t\t\t\t\tparsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n\t\t\t\t} else {\n\t\t\t\t\toffset = _offsetToPx(parsedEnd.substr(2), size);\n\t\t\t\t\tparsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\t\t\t\t\tparsedEndTrigger = trigger;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, isViewport, max)) || -0.001;\n\t\t\tchange = (end - start) || ((start -= 0.01) && 0.001);\n\t\t\tif (pin) {\n\t\t\t\ti = pinIndex;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcurTrigger = _triggers[i];\n\t\t\t\t\tif (curTrigger.pin === pin && curTrigger.start - curTrigger._pinPush < start) {\n\t\t\t\t\t\totherPinOffset += curTrigger.end - curTrigger.start;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart += otherPinOffset;\n\t\t\t\tend += otherPinOffset;\n\t\t\t\tself._pinPush = otherPinOffset;\n\t\t\t\tif (markerStart && otherPinOffset) { // offset the markers if necessary\n\t\t\t\t\tcs = {};\n\t\t\t\t\tcs[direction.a] = \"+=\" + otherPinOffset;\n\t\t\t\t\tgsap.set([markerStart, markerEnd], cs);\n\t\t\t\t}\n\t\t\t\tcs = _getComputedStyle(pin);\n\t\t\t\tisVertical = (direction === _vertical);\n\t\t\t\tscroll = self.scroll(); // recalculate because the triggers can affect the scroll\n\t\t\t\tpinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n\t\t\t\t_swapPinIn(pin, spacer, cs);\n\t\t\t\tpinState = _getState(pin);\n\t\t\t\t// transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\t\t\t\tbounds = _getBounds(pin, true);\n\t\t\t\tif (pinSpacing) {\n\t\t\t\t\tspacer.style[pinSpacing + direction.os2] = change + otherPinOffset + _px;\n\t\t\t\t\tspacingActive = (pinSpacing === _padding) ? _getSize(pin, direction) + change + otherPinOffset : 0;\n\t\t\t\t\tspacingActive && (spacer.style[direction.d] = spacingActive + _px); // for box-sizing: border-box (must include padding).\n\t\t\t\t\tisViewport && self.scroll(prevScroll);\n\t\t\t\t}\n\t\t\t\tif (isViewport) {\n\t\t\t\t\toverride = {\n\t\t\t\t\t\ttop: (bounds.top + (isVertical ? scroll - start : 0)) + _px,\n\t\t\t\t\t\tleft: (bounds.left + (isVertical ? 0 : scroll - start)) + _px,\n\t\t\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\t\t\tposition: \"fixed\"\n\t\t\t\t\t};\n\t\t\t\t\toverride[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n\t\t\t\t\toverride[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n\t\t\t\t\toverride[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n\t\t\t\t\toverride[_padding] = cs[_padding];\n\t\t\t\t\toverride[_padding + _Top] = cs[_padding + _Top];\n\t\t\t\t\toverride[_padding + _Right] = cs[_padding + _Right];\n\t\t\t\t\toverride[_padding + _Bottom] = cs[_padding + _Bottom];\n\t\t\t\t\toverride[_padding + _Left] = cs[_padding + _Left];\n\t\t\t\t\tpinActiveState = _copyState(pinOriginalState, override, pinReparent);\n\t\t\t\t}\n\t\t\t\tif (animation) { // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n\t\t\t\t\tanimation.progress(1, true);\n\t\t\t\t\tpinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n\t\t\t\t\tchange !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\t\t\t\t\tanimation.progress(0, true);\n\t\t\t\t} else {\n\t\t\t\t\tpinChange = change\n\t\t\t\t}\n\t\t\t\tif (pinIndex) { // make sure we revert from first to last to make sure things reach their end state properly\n\t\t\t\t\tfor (i = 0; i < pinIndex; i++) {\n\t\t\t\t\t\t_triggers[i].pin === pin && _triggers[i].revert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (trigger && self.scroll()) { // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n\t\t\t\tbounds = trigger.parentNode;\n\t\t\t\twhile (bounds && bounds !== _body) {\n\t\t\t\t\tif (bounds._pinOffset) {\n\t\t\t\t\t\tstart -= bounds._pinOffset;\n\t\t\t\t\t\tend -= bounds._pinOffset;\n\t\t\t\t\t}\n\t\t\t\t\tbounds = bounds.parentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.start = start;\n\t\t\tself.end = end;\n\t\t\tself.scroll() < prevScroll && self.scroll(prevScroll);\n\t\t\tself.revert(false);\n\t\t\t_refreshing = 0;\n\t\t\tprevAnimProgress && isToggle && animation.progress(prevAnimProgress, true);\n\t\t\tif (prevProgress !== self.progress) { // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n\t\t\t\tscrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\t\t\t\tself.progress = prevProgress;\n\t\t\t\tself.update();\n\t\t\t}\n\t\t\tpin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n\t\t\tonRefresh && onRefresh(self);\n\t\t};\n\n\t\tself.getVelocity = () => ((self.scroll() - scroll2) / (_getTime() - _time2) * 1000) || 0;\n\n\t\tself.update = (reset, recordVelocity) => {\n\t\t\tlet scroll = self.scroll(),\n\t\t\t\tp = reset ? 0 : (scroll - start) / change,\n\t\t\t\tclipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n\t\t\t\tprevProgress = self.progress,\n\t\t\t\tisActive, wasActive, toggleState, action, stateChanged, toggled;\n\t\t\tif (recordVelocity) {\n\t\t\t\tscroll2 = scroll1;\n\t\t\t\tscroll1 = scroll;\n\t\t\t\tif (snap) {\n\t\t\t\t\tsnap2 = snap1;\n\t\t\t\t\tsnap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\t\t\t(anticipatePin && !clipped && pin && !_refreshing && start < scroll + ((scroll - scroll2) / (_getTime() - _time2)) * anticipatePin) && (clipped = 0.0001);\n\t\t\tif (clipped !== prevProgress && enabled) {\n\t\t\t\tisActive = self.isActive = !!clipped && clipped < 1;\n\t\t\t\twasActive = !!prevProgress && prevProgress < 1;\n\t\t\t\ttoggled = isActive !== wasActive;\n\t\t\t\tstateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\t\t\t\tself.direction = clipped > prevProgress ? 1 : -1;\n\t\t\t\tself.progress = clipped;\n\t\t\t\tif (!isToggle) {\n\t\t\t\t\tif (scrubTween && !_refreshing && !_startup) {\n\t\t\t\t\t\tscrubTween.vars.totalProgress = clipped;\n\t\t\t\t\t\tscrubTween.invalidate().restart();\n\t\t\t\t\t} else if (animation) {\n\t\t\t\t\t\tanimation.totalProgress(clipped, !!_refreshing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pin) {\n\t\t\t\t\treset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\t\t\t\t\tif (!isViewport) {\n\t\t\t\t\t\tpinSetter(pinStart + pinChange * clipped);\n\t\t\t\t\t} else if (stateChanged) {\n\t\t\t\t\t\taction = !reset && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\t\t\t\t\t\tif (pinReparent) {\n\t\t\t\t\t\t\tif (!_refreshing && (isActive || action)) {\n\t\t\t\t\t\t\t\tlet bounds = _getBounds(pin, true),\n\t\t\t\t\t\t\t\t\toffset = scroll - start;\n\t\t\t\t\t\t\t\tpin.style.top = (bounds.top + (direction === _vertical ? offset : 0)) + _px;\n\t\t\t\t\t\t\t\tpin.style.left = (bounds.left + (direction === _vertical ? 0 : offset)) + _px;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_reparent(pin, !_refreshing && (isActive || action) ? _body : spacer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_setState(isActive || action ? pinActiveState : pinState);\n\t\t\t\t\t\t(pinChange !== change && clipped < 1 && isActive) || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (snap && !tweenTo.tween && !_refreshing && !_startup) {\n\t\t\t\t\tscrubScrollTime = _lastScrollTime;\n\t\t\t\t\tsnapDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t\ttoggleClass && toggled && (!once || isActive) && _toArray(toggleClass.targets).forEach(el => el.classList[isActive ? \"add\" : \"remove\"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.\n\t\t\t\tonUpdate && !isToggle && !reset && onUpdate(self);\n\t\t\t\tif (stateChanged && !_refreshing) {\n\t\t\t\t\ttoggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\t\t\t\t\tif (isToggle) {\n\t\t\t\t\t\taction = (!toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1]) || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\t\t\t\t\t\tif (animation && (action === \"complete\" || action === \"reset\" || action in animation)) {\n\t\t\t\t\t\t\tif (action === \"complete\") {\n\t\t\t\t\t\t\t\tanimation.pause().totalProgress(1);\n\t\t\t\t\t\t\t} else if (action === \"reset\") {\n\t\t\t\t\t\t\t\tanimation.restart(true).pause();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tanimation[action]();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonUpdate && onUpdate(self);\n\t\t\t\t\t}\n\t\t\t\t\tif (toggled || !_limitCallbacks) { // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n\t\t\t\t\t\tonToggle && toggled && onToggle(self);\n\t\t\t\t\t\tcallbacks[toggleState] && callbacks[toggleState](self);\n\t\t\t\t\t\tonce && (clipped === 1 ? self.kill() : (callbacks[toggleState] = 0)); // a callback shouldn't be called again if once is true.\n\t\t\t\t\t\tif (!toggled) { // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n\t\t\t\t\t\t\ttoggleState = clipped === 1 ? 1 : 3;\n\t\t\t\t\t\t\tcallbacks[toggleState] && callbacks[toggleState](self);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (isToggle && onUpdate && !_refreshing) {\n\t\t\t\t\tonUpdate(self);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update absolutely-positioned markers (only if the scroller isn't the viewport)\n\t\t\tif (markerEndSetter) {\n\t\t\t\tmarkerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));\n\t\t\t\tmarkerEndSetter(scroll);\n\t\t\t}\n\t\t};\n\n\t\tself.enable = () => {\n\t\t\tif (!enabled) {\n\t\t\t\tenabled = true;\n\t\t\t\t_addListener(scroller, \"resize\", _onResize);\n\t\t\t\t_addListener(scroller, \"scroll\", _onScroll);\n\t\t\t\tonRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\t!animation || !animation.add ? self.refresh() : gsap.delayedCall(0.01, self.refresh) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick.\n\t\t\t}\n\t\t};\n\n\t\tself.disable = reset => {\n\t\t\tif (enabled) {\n\t\t\t\tenabled = self.isActive = false;\n\t\t\t\tscrubTween && scrubTween.pause();\n\t\t\t\treset !== enabled && self.update(1);\n\t\t\t\tpin && _swapPinOut(pin, spacer, pinOriginalState);\n\t\t\t\tonRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\t\t\t\tif (snapDelayedCall) {\n\t\t\t\t\tsnapDelayedCall.pause();\n\t\t\t\t\ttweenTo.tween && tweenTo.tween.kill();\n\t\t\t\t}\n\t\t\t\tif (!isViewport) {\n\t\t\t\t\tlet i = _triggers.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n\t\t\t\t\t\t\treturn; //don't remove the listeners if there are still other triggers referencing it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_removeListener(scroller, \"resize\", _onResize);\n\t\t\t\t\t_removeListener(scroller, \"scroll\", _onScroll);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tself.kill = reset => {\n\t\t\tself.disable(reset);\n\t\t\tid && (delete _ids[id]);\n\t\t\tlet i = _triggers.indexOf(self);\n\t\t\t_triggers.splice(i, 1);\n\t\t\ti === _i && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n\t\t\tanimation && (animation.scrollTrigger = null);\n\t\t};\n\n\t\tself.enable();\n\t}\n\n\n\tstatic register(core) {\n\t\tgsap = core || _getGSAP();\n\t\tif (_windowExists() && window.document) {\n\t\t\t_win = window;\n\t\t\t_doc = document;\n\t\t\t_docEl = _doc.documentElement;\n\t\t\t_body = _doc.body;\n\t\t}\n\t\tif (gsap) {\n\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t_clamp = gsap.utils.clamp;\n\t\t\tgsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\t\t\tif (_body) {\n\t\t\t\t_raf = _win.requestAnimationFrame || (f => setTimeout(f, 16));\n\t\t\t\t_addListener(_win, \"mousewheel\", _onScroll);\n\t\t\t\t_root = [_win, _doc, _docEl, _body];\n\t\t\t\t_addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\t\t\t\tlet bodyStyle = _body.style,\n\t\t\t\t\tborder = bodyStyle.borderTop,\n\t\t\t\t\tbounds;\n\t\t\t\tbodyStyle.borderTop = \"1px solid #000\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\t\t\t\tbounds = _getBounds(_body);\n\t\t\t\t_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\t\t\t\t_horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n\t\t\t\tborder ? (bodyStyle.borderTop = border) : bodyStyle.removeProperty(\"border-top\");\n\t\t\t\t_syncInterval = setInterval(_sync, 100);\n\t\t\t\tgsap.delayedCall(0.5, () => _startup = 0);\n\t\t\t\t_addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\t\t\t\t_addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\t\t\t\t_multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", () => _pointerIsDown = 1);\n\t\t\t\t_multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", () => _pointerIsDown = 0);\n\t\t\t\t_transformProp = gsap.utils.checkPrefix(\"transform\");\n\t\t\t\t_stateProps.push(_transformProp);\n\t\t\t\t_coreInitted = _getTime();\n\t\t\t\t_resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n\t\t\t\t_addListener(_doc, \"visibilitychange\", () => _doc.hidden || _refreshAll());\n\t\t\t\t_addListener(_doc, \"DOMContentLoaded\", _refreshAll);\n\t\t\t\t_addListener(_win, \"load\", () => _lastScrollTime || _refreshAll());\n\t\t\t\t_addListener(_win, \"resize\", _onResize);\n\t\t\t}\n\t\t}\n\t\treturn _coreInitted;\n\t}\n\n\tstatic defaults(config) {\n\t\tfor (let p in config) {\n\t\t\t_defaults[p] = config[p];\n\t\t}\n\t}\n\n\tstatic kill() {\n\t\t_enabled = 0;\n\t\t_triggers.slice(0).forEach(trigger => trigger.kill(1));\n\t}\n\n\tstatic config(vars) {\n\t\t(\"limitCallbacks\" in vars) && (_limitCallbacks = !!vars.limitCallbacks);\n\t\tlet ms = vars.syncInterval;\n\t\tms && clearInterval(_syncInterval) || ((_syncInterval = ms) && setInterval(_sync, ms));\n\t}\n\n}\n\nScrollTrigger.version = \"3.3.4\";\nScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);\nScrollTrigger.refresh = safe => safe ? _onResize() : _refreshAll(true);\nScrollTrigger.update = _updateAll;\nScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);\nScrollTrigger.getScrollFunc = (element, horizontal) => (horizontal = horizontal ? _horizontal : _vertical) && (_isViewport(element) ? horizontal.sc : _getScrollFunc(element, horizontal));\nScrollTrigger.getById = id => _ids[id];\nScrollTrigger.getAll = () => _triggers.slice(0);\nScrollTrigger.isScrolling = () => !!_lastScrollTime;\nScrollTrigger.addEventListener = (type, callback) => {\n\tlet a = _listeners[type] || (_listeners[type] = []);\n\t~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = (type, callback) => {\n\tlet a = _listeners[type],\n\t\ti = a && a.indexOf(callback);\n\ti >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = (targets, vars) => {\n\tlet result = [],\n\t\tvarsCopy = {},\n\t\tinterval = vars.interval || 0.016,\n\t\tbatchMax = vars.batchMax || 1e9,\n\t\tproxyCallback = (type, callback) => {\n\t\t\tlet elements = [],\n\t\t\t\ttriggers = [],\n\t\t\t\tdelay = gsap.delayedCall(interval, () => {callback(elements, triggers); elements = []; triggers = [];}).pause();\n\t\t\treturn self => {\n\t\t\t\telements.length || delay.restart(true);\n\t\t\t\telements.push(self.trigger);\n\t\t\t\ttriggers.push(self);\n\t\t\t\tbatchMax <= elements.length && delay.progress(1);\n\t\t\t};\n\t\t},\n\t\tp;\n\tfor (p in vars) {\n\t\tvarsCopy[p] = (p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\") ? proxyCallback(p, vars[p]) : vars[p];\n\t}\n\tif (_isFunction(batchMax)) {\n\t\tbatchMax = batchMax();\n\t\t_addListener(ScrollTrigger, \"refresh\", () => batchMax = vars.batchMax());\n\t}\n\t_toArray(targets).forEach(target => {\n\t\tlet config = {};\n\t\tfor (p in varsCopy) {\n\t\t\tconfig[p] = varsCopy[p];\n\t\t}\n\t\tconfig.trigger = target;\n\t\tresult.push(ScrollTrigger.create(config));\n\t});\n\treturn result;\n}\n\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\nexport { ScrollTrigger as default };"],"names":["_passThrough","v","_windowExists","window","_getGSAP","gsap","registerPlugin","_isViewport","e","_root","indexOf","_getScrollFunc","element","s","value","arguments","length","_maxScroll","d2","Math","max","_docEl","_body","_win","_isString","_isFunction","_isNumber","_isObject","_getComputedStyle","getComputedStyle","_setDefaults","obj","defaults","p","_getBounds","withoutTransforms","tween","_transformProp","to","x","y","xPercent","yPercent","rotation","rotationX","rotationY","scale","skewX","skewY","progress","bounds","getBoundingClientRect","kill","_getSize","_multiListener","func","types","callback","split","forEach","type","_addListener","addEventListener","passive","_removeListener","removeEventListener","_offsetToPx","size","eqIndex","relative","charAt","parseFloat","substr","_keywords","_createMarker","name","container","direction","offset","matchWidthEl","startColor","endColor","fontSize","indent","fontWeight","_doc","createElement","isViewport","isScroller","parent","isStart","color","css","_vertical","_right","_bottom","offsetWidth","_isStart","setAttribute","style","cssText","innerText","insertBefore","children","_offset","op","_positionMarker","_sync","_request","_raf","_updateAll","_onScroll","_lastScrollTime","_dispatch","_getTime","_onResize","_refreshing","_resizeDelay","restart","_refreshAll","force","refreshInits","l","_triggers","_i","scroll","rec","refresh","result","render","_swapPinOut","pin","spacer","state","_setState","parentNode","removeChild","_swapPinIn","cs","i","_propNamesToCopy","spacerStyle","pinStyle","position","overflow","boxSizing","_width","_horizontal","_px","_height","_padding","_margin","_top","_left","appendChild","_getState","_stateProps","push","t","_parsePosition","trigger","scrollerSize","marker","markerScroller","self","scrollerBounds","borderWidth","scrollerMax","localOffset","globalOffset","display","_toArray","offsets","left","top","removeProperty","d","m","round","_getTweenCreator","scroller","lastScroll","getScroll","sc","prop","p2","getTween","scrollTo","vars","initialValue","change1","change2","onComplete","modifiers","ratio","call","_coreInitted","_clamp","_time2","_syncInterval","_pointerIsDown","_limitCallbacks","_startup","Date","now","_time1","_enabled","_abs","abs","_scrollLeft","_scrollTop","_Right","_Left","_Top","_Bottom","_Width","_Height","os","os2","a","pageXOffset","pageYOffset","_markerDefaults","_defaults","toggleActions","anticipatePin","center","bottom","right","start","flipped","side","oppositeSide","_isFlipped","set","_ids","_listeners","_emptyArray","map","f","time","recordVelocity","update","concat","_capsExp","replace","toLowerCase","_winOffsets","_prefixExp","ScrollTrigger","init","animation","this","tweenTo","pinCache","snapFunc","isReverted","scroll1","scroll2","end","markerStart","markerEnd","markerStartTrigger","markerEndTrigger","markerVars","change","pinOriginalState","pinActiveState","pinState","pinGetter","pinSetter","pinStart","pinChange","spacingStart","spacingActive","markerStartSetter","markerEndSetter","snap1","snap2","scrubScrollTime","scrubTween","scrubSmooth","snapDurClamp","snapDelayedCall","enabled","nodeType","horizontal","onUpdate","toggleClass","id","onToggle","onRefresh","scrub","pinSpacing","invalidateOnRefresh","onScrubComplete","onSnapComplete","once","snap","pinReparent","isToggle","scrollerCache","core","getCache","callbacks","onEnter","onLeave","onEnterBack","onLeaveBack","markers","softRefresh","onRefreshInit","tweenScroll","lazy","_initted","immediateRender","pause","scrollTrigger","ease","duration","snapTo","_getLabels","labels","utils","min","delayedCall","delay","totalProgress","velocity","naturalEnd","endValue","endScroll","data","targets","className","force3D","getProperty","quickSetter","_makePositionable","revert","r","soft","prevScroll","prevProgress","prevAnimProgress","invalidate","isVertical","override","curTrigger","otherPinOffset","parsedEnd","parsedEndTrigger","endTrigger","parsedStart","pinIndex","_pinPush","ceil","width","height","_copyState","omitOffsets","splice","_pinOffset","getVelocity","reset","isActive","toggleState","action","stateChanged","toggled","clipped","_reparent","_stOrig","test","el","classList","enable","add","disable","register","document","documentElement","body","toArray","clamp","globals","requestAnimationFrame","setTimeout","bodyStyle","border","borderTop","setInterval","checkPrefix","hidden","config","slice","limitCallbacks","ms","syncInterval","clearInterval","console","warn","version","create","safe","maxScroll","getScrollFunc","getById","getAll","isScrolling","batch","proxyCallback","elements","triggers","interval","batchMax","varsCopy","target"],"mappings":"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"}